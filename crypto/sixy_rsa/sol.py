'''
Use Fermat factorisation on n to try recovering p, q given no other information
https://en.wikipedia.org/wiki/Fermat%27s_factorization_method
https://youtu.be/nGECWdjzX4A
'''
import sympy
import math
import sympy.ntheory.primetest

n = 35888443649215837234797569407051902470334611116340922705555499895481326173802413010888654904222534728431463417655840874783313599467563789358243083608563532613050537535778109734168771783662089350144161364853683043670781378407508646364860216149686248285780811004695312939505091534468888836923824470032525579793315070451201130748444366050066480740842907227821304526295188856795623964153519902998362226079061300157950308731588343716322143063760047033971880270637563141424676074001926788722979415021729903622900478892307217085297137544012009032729312086004178102348884486387554352177764476351737773894347762865099416699857340625005387889651551238175614184443051090013560961653279900678521059472149485296193948847355061603037502718185455304238869272116923710468925396467096200478576927061188338395877082267
ct = 1656472481073638747465492664379006674324254639460323388004713724253124013242522723959131354278347284969416595022481075310901761467345163246317845102659136626059272092244384330559457414111795650141480255185674847556210048273413873824124225175493632554117145949698814232773047449816962323181380380537464648815307143743046623498841303556236180926590747800150764624188295283315108643351458219815992120139582713637869942043020441802948651353521951669778460157275279563631042920390957544558834371218711744267349812216576205837158838116940938984460411124981829178136744309123654677840423365708988676551823209635724692952386007211765769292199087299222855185220905117596833176781450946467174205839686398778566394553649772570990660641721067552027624172354194210417189348526151557440990239347865650160251618033
def ferm(n):
    sqrn = math.isqrt(n)
    for x in range(sqrn, sqrn + 10):
        # Let (p+q)/2 = x, (p-q)/2 = y
        # Find i >= sqrt(n) such that x**2 - n = y**2
        if x == 5:
            print(x**2 - n)
        if sympy.ntheory.primetest.is_square(x**2 - n):
            # Recover p, q where p = x + y and q = x - y
            y = math.isqrt(x**2 - n)
            return x + y, x - y
        
p, q = ferm(n)
print(f"p={p}\nq={q}")

def modInv(a, m):
    gcd, x, _ = extendedGCD(a, m)
    if gcd != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m

def extendedGCD(a, b):
    if a == 0:
        return b, 0, 1
    else:
        gcd, x, y = extendedGCD(b % a, a)
        return gcd, y - (b // a) * x, x

def dec(p, q, e=65537):
    # de = 1 mod phi
    phi = (p-1) * (q-1)
    d = modInv(e, phi)
    pt = pow(ct, d, n)
    return pt

from Crypto.Util.number import long_to_bytes
print("Flag:", long_to_bytes(dec(p, q)).decode('utf-8'))
